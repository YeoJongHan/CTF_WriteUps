# 10000

## Descript

> Ok hotshot, this is it, the only thing standing between you and slightly less internet anonymity.
>
> ***
>
> 7-zip password: flare

{% embed url="https://drive.google.com/file/d/14GWirCohIyVB9t7qTq10AgTDkziCQ2vE/view?usp=sharing" %}

## Solution

### TL;DR

*

## Analysis

### Finding the main function

We are given a Windows executable that is over 1GB. Running the executable, we see an error message "invalid license file". We can open the executable in IDA and search for this string.

<figure><img src="../../.gitbook/assets/image (54).png" alt=""><figcaption><p>Error message</p></figcaption></figure>

Looking at the string references, we can see that `sub_140001E87` uses it.  We can see that another function `sub_140001180` calls this function, but it just seems to be running some initialization stuff so we don't have to bother reversing it. We can rename `sub_140001E87` to `mainFunction`.

### Main function analysis

Since the executable is stripped, most of the function names are unknown. We can guess some of the through analysis, like how `sub_1400C7680` is like `printf` because of the arguments passed into it ("checking license file..." as 2nd argument).

{% hint style="info" %}
You can load FLIRT signatures to resolve most of the functions. I managed to resolve some but not all, so this writeup will demonstrate the resolution of functions **without** FLIRT signatures.
{% endhint %}

We also see "license.bin" being passed as the 2nd argument into function `sub_14009E480`, from which we can assume its `fopen`. From this method,  we can resolve functions like `fread` and `fseek`. `fread` reads the file contents into a variable we will rename to `filecontent`.

Looking at the function `sub_14001F990`, we see that it eventually calls the `sub_14001E750`, which uses a string "picosha2.h" as argument. Searching for this online, we can see that it is used in a library that generates a SHA256 hash ([https://github.com/okdshin/PicoSHA2](https://github.com/okdshin/PicoSHA2)). Looking at the examples in the GitHub page, we can infer that `sub_14001F990` is essentially `picosha2::hash256` as the arguments also makes sense. If we debug the executable, we can also see that the function does indeed write the SHA256 hash of the contents of "license.bin" into the 3rd argument of the `hash256` function.

If we rename the functions and variables, this is what we have now:

<figure><img src="../../.gitbook/assets/image (53).png" alt=""><figcaption><p>IDA File operations</p></figcaption></figure>

### Finding the goal

A bunch of code is then executed, which we will check out later. We first see how this generate hash will be used. In the `mainFunction`, we see that `sub_14001D6A0` is called with the hash as the 3rd argument. The 1st argument passed is a global variable that points to a bunch of random bytes, which is a size of 80 bytes. This can be guessed to be our ciphertext that needs to be decrypted.

In the function we also see that it eventually calls `sub_14001D8F0`, which calls another function with the "Invalid key size" as an argument. These hints of it requiring a fixed key size and the random bytes is 80 bytes long which can be placed in blocks of 16 bytes highly points to this function being a AES decryption.

```cpp
decryptFlag((__int64)&ciphertext, 0x50u, (__int64)hashbegin, 0x20u, (__int64)&iv, &Src[4], v10, (unsigned int *)Src);
```

Looking at the arguments to this decryption function, the 2nd argument seems to signify the size of ciphertext, 4th argument is the size of the hash (AES key), and the 5th argument to a global variable containing 16 bytes, which highly suggest that it is the IV key. This gives us an idea that it is most likely performing AES CBC decryption.

> GPT with IDA MCP can be used to confirm that the function is indeed performing AES CBC decryption.

From this, we can derive that we must recover the expected "license.bin" in order to decrypt the ciphertext for the flag.

### Reversing license checks

There are several checks in play. The first is for the size of "license.bin" to be **340000** bytes.

```cpp
    fopen_0((const char *)fd, "license.bin");
    sub_14007EDF0((__int64)v15, fd);
    filesize = file_size((__int64)v15);
    if ( filesize == 340000 )
```

The variable we renamed to `filecontent` is an array of 2 bytes. This is then assigned to another variable, then these 2 bytes are checked to make sure its not more than 9999. These are performed in the `for` loop, which seems to be the most important part of the license checking.

{% code fullWidth="false" %}
```cpp
    for ( position = 0; position <= 9999; ++position )
    {
      recordId = *file_content_ptr;
      if ( recordId > 9999u )
        goto invalidJmp;
      sub_1400AFB10((__int64)v17, (__int64)v12, recordId);
      if ( sub_140028F80((__int64)v17) )
        goto invalidJmp;
      sub_1400AFB10((__int64)v18, (__int64)v12, recordId);
      sub_14009DED0((__int64)v18, 1);
      ++file_content_ptr;
      v23 = sub_140001482(recordId);
      v4 = (__int64)(v23 + 1);
      v21 = &v20;
      sub_1400B46B0((__int64)v19, (__int64)"_Z5checkPh", (__int64)&v20);
      v5 = (__int64 (__fastcall **)(unsigned __int16 *))sub_1400AB330(v4, (__int64)v19);
      LODWORD(v4) = (*v5)(file_content_ptr) ^ 1;
      sub_1400B4C10((__int64)v19);
      if ( (_BYTE)v4 )
        goto invalidJmp;
      file_content_ptr += 16;
      sub_140001D9F(position);
    }
```
{% endcode %}

We can see a clear pattern here. A `for` loop running for 10000 iterations where each `recordId` (2 bytes) is checked to be less than 9999 signifies an indexing of some sort. `file_content_ptr` is then incremented (by 2 bytes) and at the end of the loop, it is incremented by 16 (32 bytes) which is off by 34 bytes effectively.

Since this iterates over 10000 times, it means there should be a total of $$10000*(32+2) = 340000$$ bytes, which matches the previous check of 340000 bytes for "license.bin".

This gives us the following struct for the license:

```cpp
struct entry {
    char id[2];
    char body[32];
}

entry license[10000];
```

### Main Logic

The first few function calls in the `for` loop isn't note worthy. The interesting part is in the function `sub_140001482`, where it takes in the id (`recordId` variable) as an argument and calls a bunch of WinAPI functions.

{% tabs %}
{% tab title="sub_140001482" %}
{% code lineNumbers="true" expandable="true" %}
```cpp
_OWORD *__fastcall sub_140001482(unsigned __int16 recordId)
{
  unsigned int v1; // esi
  __int64 v2; // rbx
  __int64 v3; // rax
  _OWORD *v4; // rbx
  _OWORD *v5; // rbx
  _OWORD *v6; // rbx
  char *v7; // rbx
  _OWORD *v8; // rsi
  _BYTE v10[24]; // [rsp+30h] [rbp-50h] BYREF
  _OWORD *v11; // [rsp+48h] [rbp-38h] BYREF
  __int64 v12; // [rsp+50h] [rbp-30h] BYREF
  __int64 v13; // [rsp+58h] [rbp-28h] BYREF
  _BYTE v14[47]; // [rsp+60h] [rbp-20h] BYREF
  char v15; // [rsp+8Fh] [rbp+Fh] BYREF
  _BYTE v16[39]; // [rsp+90h] [rbp+10h] BYREF
  char v17; // [rsp+B7h] [rbp+37h] BYREF
  char *v18; // [rsp+B8h] [rbp+38h]
  char *v19; // [rsp+C0h] [rbp+40h]
  FARPROC ProcAddress; // [rsp+C8h] [rbp+48h]
  char *v21; // [rsp+D0h] [rbp+50h]
  HMODULE hModule; // [rsp+D8h] [rbp+58h]
  INT_PTR (__stdcall *v23)(); // [rsp+E0h] [rbp+60h]
  char *v24; // [rsp+E8h] [rbp+68h]
  _OWORD *v25; // [rsp+F0h] [rbp+70h]
  unsigned __int16 v26; // [rsp+FEh] [rbp+7Eh]
  char *String; // [rsp+100h] [rbp+80h]
  char *v28; // [rsp+108h] [rbp+88h]
  unsigned __int16 v29; // [rsp+116h] [rbp+96h]
  char *v30; // [rsp+118h] [rbp+98h]
  char *v31; // [rsp+120h] [rbp+A0h]
  int v32; // [rsp+12Ch] [rbp+ACh]
  char *v33; // [rsp+130h] [rbp+B0h]
  char *v34; // [rsp+138h] [rbp+B8h]
  int v35; // [rsp+144h] [rbp+C4h]
  char *v36; // [rsp+148h] [rbp+C8h]
  char *v37; // [rsp+150h] [rbp+D0h]
  char *v38; // [rsp+158h] [rbp+D8h]
  char *v39; // [rsp+160h] [rbp+E0h]
  char *v40; // [rsp+168h] [rbp+E8h]
  char *v41; // [rsp+170h] [rbp+F0h]
  __int64 v42; // [rsp+178h] [rbp+F8h]
  __int64 v43; // [rsp+180h] [rbp+100h]
  int v44; // [rsp+188h] [rbp+108h]
  DWORD v45; // [rsp+18Ch] [rbp+10Ch]
  LPVOID v46; // [rsp+190h] [rbp+110h]
  HGLOBAL hResData; // [rsp+198h] [rbp+118h]
  HRSRC hResInfo; // [rsp+1A0h] [rbp+120h]
  unsigned int *m; // [rsp+1A8h] [rbp+128h]
  unsigned int *v50; // [rsp+1B0h] [rbp+130h]
  unsigned int k; // [rsp+1BCh] [rbp+13Ch]
  FARPROC *v52; // [rsp+1C0h] [rbp+140h]
  char *j; // [rsp+1C8h] [rbp+148h]
  int i; // [rsp+1D4h] [rbp+154h]
  unsigned int *v55; // [rsp+1D8h] [rbp+158h]

  v1 = recordId;
  v2 = sub_1400AF750(&unk_140112C80);
  v3 = sub_1400AF780(&unk_140112C80);
  v12 = sub_1400023B1(v3, v2, v1);
  v13 = sub_1400AF750(&unk_140112C80);
  if ( (unsigned __int8)sub_140021500(&v12, &v13) != 1 )
    return *(_OWORD **)sub_1400230F0(&v12);
  v5 = (_OWORD *)sub_1400C9F00(0x40uLL);
  *v5 = 0LL;
  v5[1] = 0LL;
  v5[2] = 0LL;
  v5[3] = 0LL;
  sub_14001D670(v5);
  v11 = v5;
  *(_WORD *)v5 = recordId;
  hResInfo = FindResourceA(0LL, (LPCSTR)recordId, (LPCSTR)0xA);
  hResData = LoadResource(0LL, hResInfo);
  v46 = LockResource(hResData);
  v45 = SizeofResource(0LL, hResInfo);
  v44 = sub_140002690(v46, v45, 0LL);
  sub_1400C0C30(v10, v44);
  v43 = sub_1400297D0(v10, 0LL);
  sub_1400035E8((_DWORD)v46, v43, v45, v44, 0LL);
  v42 = *(int *)(v43 + 60) + v43;
  v41 = (char *)VirtualAlloc(0LL, *(unsigned int *)(v42 + 80), 0x3000u, 0x40u);
  *((_QWORD *)v11 + 1) = v41;
  v55 = (unsigned int *)(v42 + 24 + *(unsigned __int16 *)(v42 + 20));
  for ( i = 0; i < *(unsigned __int16 *)(v42 + 6); ++i )
  {
    memcpy(&v41[v55[3]], (const void *)(v43 + v55[5]), v55[4]);
    v55 += 10;
  }
  for ( j = &v41[*(unsigned int *)(v42 + 144)]; *((_DWORD *)j + 3); j += 20 )
  {
    String = &v41[*((unsigned int *)j + 3)];
    v52 = (FARPROC *)&v41[*((unsigned int *)j + 4)];
    if ( (unsigned int)(*String - 48) > 9
      || (unsigned int)(String[1] - 48) > 9
      || (unsigned int)(String[2] - 48) > 9
      || (unsigned int)(String[3] - 48) > 9 )
    {
      hModule = LoadLibraryA(String);
      while ( *v52 )
      {
        v21 = &v41[(_QWORD)*v52];
        ProcAddress = GetProcAddress(hModule, v21 + 2);
        *v52++ = ProcAddress;
      }
    }
    else
    {
      v26 = atoi(String);
      v25 = sub_140001482(v26);
      while ( *v52 )
      {
        v24 = &v41[(_QWORD)*v52];
        v6 = v25 + 1;
        v19 = &v15;
        sub_1400B46B0(v14, v24 + 2, &v15);
        v23 = *(INT_PTR (__stdcall **)())sub_1400AB330(v6, v14);
        sub_1400B4C10(v14);
        *v52++ = v23;
      }
    }
  }
  v40 = &v41[*(unsigned int *)(v42 + 136)];
  v39 = &v41[*((unsigned int *)v40 + 8)];
  v38 = &v41[*((unsigned int *)v40 + 9)];
  v37 = &v41[*((unsigned int *)v40 + 7)];
  for ( k = 0; k < *((_DWORD *)v40 + 6); ++k )
  {
    v30 = &v41[*(unsigned int *)&v39[4 * k]];
    v29 = *(_WORD *)&v38[2 * k];
    v28 = &v41[*(unsigned int *)&v37[4 * v29]];
    v7 = v28;
    v8 = v11 + 1;
    v18 = &v17;
    sub_1400B46B0(v16, v30, &v17);
    *(_QWORD *)sub_1400AB330(v8, v16) = v7;
    sub_1400B4C10(v16);
  }
  v36 = &v41[*(unsigned int *)(v42 + 176)];
  v35 = *(_DWORD *)(v42 + 180);
  v50 = (unsigned int *)v36;
  v34 = &v41[-*(_QWORD *)(v42 + 48)];
  while ( v50 < (unsigned int *)&v36[v35] )
  {
    for ( m = v50 + 2; m < (unsigned int *)((char *)v50 + v50[1]); m = (unsigned int *)((char *)m + 2) )
    {
      v31 = &v41[(*(_WORD *)m & 0xFFF) + (unsigned __int64)*v50];
      switch ( *((_BYTE *)m + 1) & 0xF0 )
      {
        case 160:
          *(_QWORD *)v31 += v34;
          break;
        case 48:
          *(_QWORD *)v31 += (unsigned int)v34;
          break;
        case 16:
          *(_QWORD *)v31 += WORD1(v34);
          break;
        case 32:
          *(_QWORD *)v31 += (unsigned __int16)v34;
          break;
      }
    }
    v50 = m;
  }
  v33 = &v41[*(unsigned int *)(v42 + 40)];
  v32 = ((__int64 (__fastcall *)(void *, __int64, _QWORD))v33)(&unk_140109040, 1LL, 0LL);
  sub_1400AF7E0(&unk_140112C80, &v11);
  v4 = v11;
  sub_140086660(v10);
  return v4;
}
```
{% endcode %}
{% endtab %}
{% endtabs %}

We see that the `recordId` is passed into [FindResourceA](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findresourcea) as the 2nd argument, which is used to specify the ID of the resource to load. If we view the resources of the executable in **CFF Explorer**, we can see why the file is over 1GB of size; it contains 10000 resources with each resource being over **0x10000** bytes big!

<figure><img src="../../.gitbook/assets/image (55).png" alt=""><figcaption><p>Resources of executable</p></figcaption></figure>

This means the specified `recordId` would specify the resource accordingly, 0 would match the first resource, and 9999 would match the last.

The resource is then loaded and a buffer is assigned its pointer. This is then passed into another important function `sub_1400035E8`, which essentially decodes the resource bytes. We can determine this by debugging, where we see the 1st argument is the input encoded bytes and the 2nd argument is the output containing the decoded bytes.

{% tabs %}
{% tab title="encoded" %}
<figure><img src="../../.gitbook/assets/image (56).png" alt=""><figcaption></figcaption></figure>
{% endtab %}

{% tab title="decoded" %}
<figure><img src="../../.gitbook/assets/image (58).png" alt=""><figcaption></figcaption></figure>
{% endtab %}
{% endtabs %}

We can also tell that the resource is essentially encoded DLLs based on the first few bytes seen in the decoded output.

### Extracting DLLs

With this, I asked GPT to code me a python script that uses the **frida** library to hook the running executable at a given address and dump out a certain number of bytes in the specified register.

The code had a lot of errors initially (mostly with running the fridaJS), but I managed to fix it by reading the documentation on the correct frida version that I'm using. This particularly fixes the retrieval of base address of the executable, the code to set the interceptor at an address, and also the reading of bytes from the address stored in the RAX register.

{% tabs %}
{% tab title="extract_dll.py" %}
{% code expandable="true" %}
```python
import frida
import os
import struct
import time
import queue
import sys
from pathlib import Path

# ---------------- CONFIG ----------------
TARGET_EXE = r"10000.exe"  # full path to executable to spawn each iteration
MODULE_NAME = "10000.exe"  # full path to executable to spawn each iteration
PATCH_FILE_PATH = r"license.bin"  # file whose first 2 bytes will be overwritten with i (uint16, little-endian)
BP_ADDR = 0x1672  # breakpoint VA (adjust for target)
DUMP_SIZE = 500000  # bytes to read from address in RAX
OUT_DIR = r".\frida_out"  # where to write the "{i}.dll" files
ITERATIONS = 10000  # number of iterations (0..ITERATIONS-1)
TIMEOUT_SECS = 15  # how long to wait for a dump each iteration
SLEEP_BETWEEN = 0.05  # small sleep between iterations
REG_NAME = "rax"  # register that contains buffer pointer
# ----------------------------------------

os.makedirs(OUT_DIR, exist_ok=True)
patch_path = Path(PATCH_FILE_PATH)
if not patch_path.exists():
    print(f"[!] patch file does not exist: {PATCH_FILE_PATH}")
    sys.exit(1)
if not os.path.exists(TARGET_EXE):
    print(f"[!] target exe not found: {TARGET_EXE}")
    sys.exit(1)

FRIDA_JS = r"""
var moduleName = {modname};
var base = Process.findModuleByName(moduleName);
var rva = {bp}
var bp = base.base.add(rva);
Interceptor.attach(bp, {{
  onEnter: function (args) {{
    try {{
      var addr = this.context.{reg};
      var size = {size};
      if (addr.isNull()) {{
        send({{ type: 'error', msg: 'rax is NULL' }});
        return;
      }}
      var memaddr = ptr(addr)
      var buf = memaddr.readByteArray(size);
      send({{ type: 'dump', addr: addr.toString(), size: size }}, buf);
    }} catch (e) {{
      send({{ type: 'error', msg: e.message }});
    }}
  }}
}});
""".format(
    modname=repr(MODULE_NAME), bp=hex(BP_ADDR), reg=REG_NAME, size=DUMP_SIZE
)


def write_first_two_bytes_le(value):
    """Write the first two bytes of PATCH_FILE_PATH with uint16 little-endian of value."""
    v16 = value & 0xFFFF
    packed = struct.pack("<H", v16)
    # open in r+b (read+write, binary)
    with open(PATCH_FILE_PATH, "r+b") as f:
        f.seek(0)
        f.write(packed)
        f.flush()
        os.fsync(f.fileno())


def spawn_attach_and_dump(iter_index):
    """Spawn the target exe suspended, attach, load script, resume, wait for dump, save and cleanup."""
    q = queue.Queue()

    def on_message(message, data):
        q.put((message, data))

    pid = None
    session = None
    script = None
    try:
        pid = frida.spawn([TARGET_EXE])
    except Exception as e:
        print(f"[iter {iter_index}] spawn failed: {e}")
        return False

    try:
        session = frida.attach(pid)
    except Exception as e:
        print(f"[iter {iter_index}] attach failed: {e}")
        try:
            frida.kill(pid)
        except Exception:
            pass
        return False

    try:
        script = session.create_script(FRIDA_JS)
        script.on("message", on_message)
        script.load()
    except Exception as e:
        print(f"[iter {iter_index}] create/load script failed: {e}")
        try:
            session.detach()
        except Exception:
            pass
        try:
            frida.kill(pid)
        except Exception:
            pass
        return False

    # resume process so it runs and will hit the bp
    try:
        frida.resume(pid)
    except Exception as e:
        print(f"[iter {iter_index}] resume failed: {e}")
        try:
            session.detach()
        except Exception:
            pass
        try:
            frida.kill(pid)
        except Exception:
            pass
        return False

    # wait for message from JS
    try:
        message, data = q.get(timeout=TIMEOUT_SECS)
    except queue.Empty:
        print(
            f"[iter {iter_index}] timed out waiting for dump (no message in {TIMEOUT_SECS}s)."
        )
        try:
            session.detach()
        except Exception:
            pass
        try:
            frida.kill(pid)
        except Exception:
            pass
        return False

    # message handling
    # message structure from frida: {'type': 'send', 'payload': {...}} or {'type': 'error', 'description': ...}
    try:
        mtype = message.get("type")
        if mtype == "send":
            payload = message.get("payload", {})
            ptype = payload.get("type")
            if ptype == "dump":
                addr_str = payload.get("addr")
                size = payload.get("size", DUMP_SIZE)
                # write binary data to file named "{i}.dll"
                outname = os.path.join(OUT_DIR, f"{iter_index}.dll")
                with open(outname, "wb") as f:
                    f.write(data)
                print(
                    f"[iter {iter_index}] wrote {size} bytes from {addr_str} -> {outname}"
                )
            else:
                # info or error sent from JS
                print(f"[iter {iter_index}] message payload: {payload}")
        else:
            # type might be 'error' (frida internal)
            print(f"[iter {iter_index}] frida message (non-send): {message}")
    except Exception as e:
        print(f"[iter {iter_index}] error processing message: {e}")

    # cleanup
    #    try:
    #        print("DETACH")
    #        session.detach()
    #        print("DETACHED!")
    #    except Exception:
    #        pass
    try:
        frida.kill(pid)
    except Exception:
        pass

    return True


def main():
    print("Starting automated loop. This will run ITERATIONS times.")
    for i in range(0, ITERATIONS):
        print(f"Running {i}")
        try:
            write_first_two_bytes_le(i)
        except Exception as e:
            print(f"[iter {i}] failed to patch file: {e}")
            time.sleep(SLEEP_BETWEEN)
            continue
        ok = spawn_attach_and_dump(i)
        if not ok:
            print(f"[iter {i}] iteration failed.")
        time.sleep(SLEEP_BETWEEN)
    print("All iterations complete.")

if __name__ == "__main__":
    main()

```
{% endcode %}
{% endtab %}
{% endtabs %}

Running this took about 2 hours to extract all the DLLs. It would be faster if the decryption function was reimplemented or if I had threaded the extraction process, but I had time so I just let it run in the background.

Looking back at the function that loads the resource, we can see that after the decoding, there are some offset calculations before copying the decoded bytes into the **VirtualAlloc**-ed region.

```cpp
  decodeDLL(dll_decode, decoded, v45, v44, 0LL);
  NtHeader = *(int *)(decoded + 0x3C) + decoded;
  vMem = (char *)VirtualAlloc(0LL, *(unsigned int *)(NtHeader + 0x50), 0x3000u, 0x40u);
  *((_QWORD *)v11 + 1) = vMem;
  sectionHeaders = (unsigned int *)(NtHeader + 0x18 + *(unsigned __int16 *)(NtHeader + 0x14));
  for ( i = 0; i < *(unsigned __int16 *)(NtHeader + 6); ++i )
  {
    memcpy(&vMem[sectionHeaders[3]], (const void *)(decoded + sectionHeaders[5]), sectionHeaders[4]);
    sectionHeaders += 10;
  }
```

For people who are familiar with reversing Windows Executables, the offsets should look familiar. I recommend using [010 Editor](https://www.sweetscape.com/010editor/) to view the DLL for easier visualization as it highlights the different fields and their sizes in a hex view.

| Offset                                                       | Significance                  |
| ------------------------------------------------------------ | ----------------------------- |
| decoded + 0x3C                                               | AddressOfNewExeHeader         |
| \*(int \*)(decoded + 0x3C) + decoded                         | NtHeader                      |
| NtHeader + 0x50                                              | SizeOfImage                   |
| NtHeader + 0x14                                              | SizeOfOptionalHeader          |
| NtHeader + 0x18                                              | OptionalHeader                |
| NtHeader + 0x18 + \*(unsigned \_\_int16 \*)(NtHeader + 0x14) | SectionHeaders                |
| NtHeader + 6                                                 | NumberOfSections              |
| sectionHeaders\[3]                                           | VirtualAddress                |
| sectionHeaders\[4]                                           | SizeOfRawData                 |
| sectionHeaders\[5]                                           | PointerToRawData              |
| decoded + sectionHeaders\[5]                                 | .text section (Start of code) |

This chunk of code essentially copies the .text section of the DLL into the (VirtualAlloc-ed region + VirtualAddress offset).

Following this code is another `for` loop:

{% code expandable="true" %}
```cpp
  for ( j = &vMem[*(unsigned int *)(NtHeader + 0x90)]; *((_DWORD *)j + 3); j += 20 )
  {
    ModName = &vMem[*((unsigned int *)j + 3)];
    FirstThunk = (FARPROC *)&vMem[*((unsigned int *)j + 4)];
    if ( (unsigned int)(*ModName - 48) > 9
      || (unsigned int)(ModName[1] - 48) > 9
      || (unsigned int)(ModName[2] - 48) > 9
      || (unsigned int)(ModName[3] - 48) > 9 )
    {
      hModule = LoadLibraryA(ModName);
      while ( *FirstThunk )
      {
        v21 = &vMem[(_QWORD)*FirstThunk];
        ProcAddress = GetProcAddress(hModule, v21 + 2);
        *FirstThunk++ = ProcAddress;
      }
    }
    else
    {
      v26 = atoi(ModName);
      v25 = loadlib(v26);
      while ( *FirstThunk )
      {
        v24 = &vMem[(_QWORD)*FirstThunk];
        v6 = (__int64)(v25 + 1);
        v19 = &v15;
        sub_7FF776D146B0((__int64)v14, (__int64)(v24 + 2), (__int64)&v15);
        v23 = *(INT_PTR (__stdcall **)())sub_7FF776D0B330(v6, (__int64)v14);
        sub_7FF776D14C10((__int64)v14);
        *FirstThunk++ = v23;
      }
    }
  }
```
{% endcode %}

Although this look complex, what it does is pretty simple:

{% stepper %}
{% step %}
Go through all the imports of the DLL
{% endstep %}

{% step %}
Check the first 4 bytes of the module name
{% endstep %}

{% step %}
If first 4 bytes of module name isn't all digits, then its a normal system provided library, so load and populate IAT.
{% endstep %}

{% step %}
Else the library is custom and should be loaded as a DLL, so recursively call the current function  to load other DLLs, then populate IAT.
{% endstep %}
{% endstepper %}

Basically, this would go through all imports of the DLL and then recursively load it.&#x20;

The rest of the code in the function isn't that important, it mainly loads things into their correct locations so that the DLL is able to run normally with the exported functions. The only important function that was called at the end is `sub_1400AE7E0`, which we will talk about later on.

Going back to the `mainFunction`, after the loading of the libraries, the exported function `_Z5checkPh` of the DLL is then loaded and ran (at 0x140001180) with the `file_content_ptr` as an argument. This can easily be deduced by debugging the executable. We can also guess that each DLL would have their own checks on each 32 bytes of body, which we would need to reverse the logic of. Repeat this 10000 times to get all the correct bytes of body for each DLL.

### Getting the right order

Before diving into the DLLs, we have to determine the order of which to load the DLLs in, that is, what is the order of `recordId`s to input.

In the `mainFunction`, there is a `memcmp` after the `for` loop ends. It compares 40000 bytes of a global variable that is initially all nulls, against a populated global variable, which is the goal we have to aim towards. We can start by looking at the references to this global variable of nulls.

```cpp
if ( memcmp(&unk_140108040, &unk_1400CB000, 40000uLL) )
```

Out of all the references, the only one that seems to change the values is found in the function `sub_140000D9F`, which is called by the `mainFunction`.

{% tabs %}
{% tab title="sub_140000D9F" %}
{% code expandable="true" %}
```cpp
__int64 __fastcall sub_140000D9F(int a1)
{
  __int64 v2; // [rsp+20h] [rbp-20h] BYREF
  __int64 v3; // [rsp+28h] [rbp-18h] BYREF
  LPVOID *v4; // [rsp+30h] [rbp-10h]
  void *v5; // [rsp+38h] [rbp-8h]

  v5 = &unk_140111C80;
  v3 = sub_1400AE780(&unk_140111C80);
  v2 = sub_1400AE750(&unk_140111C80);
  while ( (unsigned __int8)sub_140020500(&v3, &v2) != 1 )
  {
    v4 = *(LPVOID **)sub_1400220F0(&v3);
    dword_140108040[*(unsigned __int16 *)v4] += a1;
    VirtualFree(v4[1], 0LL, 0x8000u);
    sub_14001F560(&v3);
  }
  return sub_1400AE7B0(&unk_140111C80);
}
```
{% endcode %}
{% endtab %}
{% endtabs %}

We can see that `sub_1400220F0` returns the index to which a certain value should be added to. If you enter the `sub_140000D9F` function in IDA and press F5 to refresh the generated decompiled code, you will see that our global variable of nulls changed from **unk...** to **dword...**.

This is because IDA identifies that 4 bytes are being added to it for each index. So when the `memcmp` compares 40000 bytes, it's actually comparing 10000 entries of 4 bytes. This matches the number of DLL ids we can input. We can convert both global variables to an array with the correct sizes.

We can also easily see that the value that it adds is the current iteration count of the `for` loop in the `mainFunction`. However to determine how the index (v4) is generated, we have to look through some confusing references...

Most of the functions in the `sub_140001D9F` function are pretty straightforward, but they suggest that the variables being worked on is of some kind of struct, especially so for `unk_140112C80`.

Renaming the variables and functions, we have this:

```cpp
__int64 __fastcall populateTarget(int iteration)
{
  __int64 endPtr; // [rsp+20h] [rbp-20h] BYREF
  __int64 startPtr; // [rsp+28h] [rbp-18h] BYREF
  unsigned __int16 *index; // [rsp+30h] [rbp-10h]
  _QWORD *v5; // [rsp+38h] [rbp-8h]

  v5 = someQueue;
  startPtr = Deref_8B((__int64)someQueue);
  endPtr = Deref_Next_8B((__int64)someQueue);
  while ( !compareDeref((__int64)&startPtr, (__int64)&endPtr) )
  {
    index = *(unsigned __int16 **)retDeref((__int64)&startPtr);
    targetInp[*index] += iteration;
    VirtualFree(*((LPVOID *)index + 1), 0LL, 0x8000u);
    goNext(&startPtr);
  }
  return sub_1400AF7B0(someQueue);
}
```

It's hard to understand completely what's going on here because the struct makes it messy, but it's actually pretty simple.

Looking at the `index` variable and its type definition "**\*(unsigned \_\_int16 \*\*)**", we can easily deduce how the struct would look like:

```cpp
struct queue {
    unsigned __int16** startPtr;
    unsigned __int16** endPtr;
}
```

`startPtr` and `endPtr` would be pointers to pointers to **int16** values. `compareDeref` would compare the 2 addresses to see if the queue ended, if the addresses are not the same, then it continues the loop. At the end of the loop, the `goNext` function would add 8 to the pointer, which makes it point to the next pointer in the queue. 8 is then added until the `startPtr` is the same address as the `endPtr`.

The `index` is the value dereferenced from the pointer that `startPtr` is pointing to.

<figure><img src="../../.gitbook/assets/demoloop.png" alt=""><figcaption><p>Loop example</p></figcaption></figure>

Now we know it retrieves the index from the queue, we need to find out how this queue is populated.

Looking at references to the queue, we see the function that loads the libraries accesses it many times. Now it's quite confusing to reverse this part on how the queue is populated. The easiest way is to debug and check the queue after the load library function is ran.

When we debug and check against the DLLs that ran, we see a certain pattern. When we load a random DLL, we see that the queue will be populated with a lot of entries. However, if we try to load **9998.dll** by putting the id as **9998** in little endian, we see that the load library function runs very quickly because the DLL does not have any imports. We can also see that the queue contains only **1** entry, which is a pointer to the current DLL index **9998**! From this, we can guess that the load library function populates the queue based on each DDL ID, including the ID of the other DLLs it imports since load library would run recursively.

Now we know that depending on the DLL ID provided, it will populate the queue with indices that are the IDs of every imported DLL recursively, and then each ID is used as an offset to the `targetInp` from which to add the order to.

In pseudo-python code, the main code of the executable is doing:

{% code expandable="true" %}
```python
def loadLib(id):
    queue.add(id)
    for import dll.imports:
        if import.is_custom() then loadLib(id)
        else LoadLibrary(import)
        populateIAT(import)

def populateTarget(increment):
    for q in queue:
        targetInp[q] += increment
    queue = []

targetInp = [0]*10000
for i in range(10000):
    id = file_content[:2]
    if id > 9999 then invalidLicense
    file_content += 2
    lib = loadLib(id)
    result = lib.call("_Z5checkPh")
    if result == 0 then invalidLicense
    file_content += 32
    populateTarget(i)
if targetInp != goal then invalidLicense
print("license valid!")
decryptFlag(ciphertext, ciphertext_size, aes_key_file_hash, hash_size, iv, plaintext)
print(plaintext)
```
{% endcode %}

Given that we know that at each loop, it adds all indices by the loop counter, how do we get the right order so that the target matches the goal?

We first need to extract all imports for every single DLL. This gives us an idea of what indices of `targetInp` are incremented for each DLL ID we give. I used GPT to generate a python script for extracting the imports recursively for each every DLL ID. This script outputs a `sets.json` containing a json file entries **{ID: list\_of\_imports}**.

{% tabs %}
{% tab title="generate_imports.py" %}
{% code expandable="true" %}
```python
import argparse
import json
import os
import re
from concurrent.futures import ProcessPoolExecutor, as_completed
from typing import Dict, Set, List, Optional, Tuple

import pefile


def is_numeric_loader_name(dll_name: str) -> bool:
    """Match the loader's check: first 4 chars must be '0'..'9'.

    In loadlib, it tested the first four characters with (unsigned)(c-48) <= 9.
    Then it used atoi(String), which parses an initial decimal sequence.
    """
    if not dll_name:
        return False
    if len(dll_name) < 4:
        return False
    s = dll_name[:4]
    return all('0' <= ch <= '9' for ch in s)


def parse_numeric_id_from_name(dll_name: str) -> Optional[int]:
    """Return decimal integer parsed from start of string (like atoi) if first 4 chars are digits.

    Examples:
      '270f.dll' -> None (4th char is 'f', not digit) per loader's check
      '9998.dll' -> 9998
      '12345_something.dll' -> 12345
    """
    if not is_numeric_loader_name(dll_name):
        return None
    m = re.match(r"^([0-9]+)", dll_name)
    if not m:
        return None
    try:
        return int(m.group(1))
    except ValueError:
        return None


def get_numeric_imports(dll_path: str) -> List[int]:
    """Return immediate numeric import ids for a DLL file (no recursion)."""
    try:
        pe = pefile.PE(dll_path, fast_load=True)
    except Exception:
        return []

    try:
        pe.parse_data_directories(
            directories=[pefile.DIRECTORY_ENTRY["IMAGE_DIRECTORY_ENTRY_IMPORT"]]
        )
    except Exception:
        return []

    out: List[int] = []
    if not hasattr(pe, "DIRECTORY_ENTRY_IMPORT"):
        return out
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        try:
            dll_name = entry.dll.decode(errors="ignore") if entry.dll else ""
        except Exception:
            dll_name = ""
        num = parse_numeric_id_from_name(dll_name)
        if num is not None:
            out.append(num)
    # Dedup while preserving order
    seen = set()
    res = []
    for x in out:
        if x not in seen:
            seen.add(x)
            res.append(x)
    return res


def _scan_one(args: Tuple[int, str]) -> Tuple[int, List[int]]:
    """Worker: return (id, immediate_numeric_import_ids)."""
    j, dll_dir = args
    path = os.path.join(dll_dir, f"{j}.dll")
    if not os.path.exists(path):
        return j, []
    return j, get_numeric_imports(path)


def build_adjacency(
    dll_dir: str, start: int, end: int, workers: int | None = None
) -> Dict[int, List[int]]:
    """Parallel pre-scan of all DLLs to build immediate numeric-import adjacency.

    Returns dict id -> list of ids. Missing DLLs map to [].
    """
    ids = list(range(start, end))
    adj: Dict[int, List[int]] = {j: [] for j in ids}
    with ProcessPoolExecutor(max_workers=workers) as exe:
        futs = {exe.submit(_scan_one, (j, dll_dir)): j for j in ids}
        for fut in as_completed(futs):
            j, lst = fut.result()
            adj[j] = lst
    return adj


def compute_closure_for_all(adj: Dict[int, List[int]]) -> Dict[int, Set[int]]:
    """Compute transitive closure sets for all nodes using DFS + memoization.

    Returns sets excluding the node itself (we add self later to match queue behavior).
    Handles cycles gracefully by tracking recursion stack.
    """
    memo: Dict[int, Set[int]] = {}
    visiting: Set[int] = set()

    def dfs(u: int) -> Set[int]:
        if u in memo:
            return memo[u]
        if u in visiting:
            # Cycle detected: return empty additional set to break the loop.
            return set()
        visiting.add(u)
        out: Set[int] = set()
        for v in adj.get(u, []):
            if v == u:
                continue
            out.add(v)
            out.update(dfs(v))
        visiting.remove(u)
        memo[u] = out
        return out

    for node in adj.keys():
        dfs(node)
    return memo


def main():
    ap = argparse.ArgumentParser(description="Generate sets.json: dll_id -> sorted list of ids enqueued (transitive numeric imports)")
    ap.add_argument("--dll-dir", default=r"D:\\files\\frida_out", help="Directory containing {id}.dll dumps")
    ap.add_argument("--start", type=int, default=0, help="Start id (inclusive)")
    ap.add_argument("--end", type=int, default=10000, help="End id (exclusive)")
    ap.add_argument("--out", default="sets.json", help="Output JSON path")
    ap.add_argument("--workers", type=int, default=None, help="Number of parallel workers for scanning (default: CPU count)")
    ap.add_argument("--adj-cache", default=None, help="Optional path to read/write adjacency JSON to skip re-scan")
    args = ap.parse_args()

    # Build or load adjacency
    adj: Dict[int, List[int]]
    if args.adj_cache and os.path.isfile(args.adj_cache):
        with open(args.adj_cache, "r", encoding="utf-8") as f:
            raw = json.load(f)
        # keys may be strings
        adj = {int(k): list(map(int, v)) for k, v in raw.items()}
    else:
        adj = build_adjacency(args.dll_dir, args.start, args.end, args.workers)
        if args.adj_cache:
            with open(args.adj_cache, "w", encoding="utf-8") as f:
                json.dump({str(k): v for k, v in adj.items()}, f)

    # Compute closures
    closures = compute_closure_for_all(adj)

    # Build final sets including self
    result: Dict[int, List[int]] = {}
    for j in range(args.start, args.end):
        print("Processing id", j)
        s = set(closures.get(j, set()))
        s.add(j)
        result[j] = sorted(s)

    # Write as dict with string keys to keep JSON smaller/compatible
    with open(args.out, "w", encoding="utf-8") as f:
        json.dump({str(k): v for k, v in result.items()}, f)

    print(
        f"Wrote {args.out} for ids in [{args.start}, {args.end}) using dll-dir {args.dll_dir}"
    )


if __name__ == "__main__":
    main()

```
{% endcode %}
{% endtab %}
{% endtabs %}

After the import lists are extracted, we can ask GPT to create another script for solving the order given the import lists and the list of goals.

The way that it solves for order is through

* Method used: constraint elimination / unit-propagation-like algorithm. It iteratively finds ids k that currently have exactly one remaining candidate DLL j (a unique contributor). That unique contributor must be placed at position pos = goal\[k]. It assigns that DLL to pos, marks all ids introduced by that DLL as covered (and checks consistency with their residuals), removes that DLL from the unknown set, and repeats until all DLLs are assigned or no progress can be made.

{% tabs %}
{% tab title="solve_order.py" %}
{% code expandable="true" %}
```python
import argparse
import json
import os
import struct
from collections import defaultdict
from typing import Dict, List, Set, Tuple, Optional


def load_goal(path: str) -> List[int]:
    ext = os.path.splitext(path)[1].lower()
    if ext in (".bin", ".dat"):
        with open(path, "rb") as f:
            data = f.read()
        if len(data) != 10000 * 4:
            raise ValueError(f"Goal bin length={len(data)} but expected 40000 bytes")
        return list(struct.unpack("<10000I", data))
    else:
        with open(path, "r", encoding="utf-8") as f:
            obj = json.load(f)
        if isinstance(obj, dict) and "goal" in obj:
            arr = obj["goal"]
        else:
            arr = obj
        if len(arr) != 10000:
            raise ValueError(f"Goal length={len(arr)} but expected 10000")
        return [int(x) & 0xFFFFFFFF for x in arr]


def load_S(path: str) -> Dict[int, Set[int]]:
    with open(path, "r", encoding="utf-8") as f:
        raw = json.load(f)
    s_by_dll: Dict[int, Set[int]] = {}
    # Accept dict[str->list], dict[int->list], or list-of-lists indexed by dll id.
    if isinstance(raw, dict):
        for k, v in raw.items():
            j = int(k)
            s_by_dll[j] = set(int(x) for x in v)
    elif isinstance(raw, list):
        for j, v in enumerate(raw):
            s_by_dll[j] = set(int(x) for x in v)
    else:
        raise ValueError("Unsupported S format")
    # Basic sanity
    for j, S in s_by_dll.items():
        for k in S:
            if not (0 <= k < 10000):
                raise ValueError(f"S[{j}] contains out-of-range id {k}")
    return s_by_dll


def build_contributors(
    s_by_dll: Dict[int, Set[int]], active: Set[int]
) -> Dict[int, Set[int]]:
    contributors: Dict[int, Set[int]] = {k: set() for k in range(10000)}
    for j in active:
        for k in s_by_dll[j]:
            contributors[k].add(j)
    return contributors


def simulate(order: List[int], s_by_dll: Dict[int, Set[int]]) -> List[int]:
    """Simulate counters under the corrected semantics:
    - gWorkQueue holds a registry of loaded modules; loadlib pushes each module once
    - ProcessWorkItemsAndAccumulate(i) processes only the newly-pushed tail since last call
      so each module k receives its position exactly once, at the iteration when it is first introduced.
    """
    counters = [0] * 10000
    seen: Set[int] = set()
    for i, j in enumerate(order):
        for k in s_by_dll[j]:
            if k not in seen:
                counters[k] = i & 0xFFFFFFFF
                seen.add(k)
    return counters


def solve_order(
    goal: List[int], s_by_dll: Dict[int, Set[int]]
) -> Tuple[Optional[List[int]], Dict[int, int]]:
    # Residual vector r initially equals goal; for each module k, r[k] should be reduced to 0 exactly once
    # when the dll that first introduces k is assigned its position.
    residual = [int(x) & 0xFFFFFFFF for x in goal]
    unknown: Set[int] = set(s_by_dll.keys())
    pos_by_dll: Dict[int, int] = {}
    contributors = build_contributors(s_by_dll, unknown)
    covered: List[bool] = [False] * 10000  # whether module k has been introduced/assigned yet

    # Pre-check: all ids must be covered by some DLL; otherwise impossible.
    for k in range(10000):
        if len(contributors.get(k, set())) == 0 and (residual[k] != 0):
            raise ValueError(f"id {k} has residual {residual[k]} but no contributors")

    progress = True
    round_no = 0
    while unknown and progress:
        progress = False
        round_no += 1

        # Step 1: assign DLLs that appear as the unique contributor for any uncovered id k
        unique_assignments: List[Tuple[int, int, int]] = []  # (dll j, pos, id k)
        for k, js in contributors.items():
            if covered[k]:
                continue
            active_js = [j for j in js if j in unknown]
            if len(active_js) == 1:
                j = active_js[0]
                pos = residual[k]
                # pos must be in 0..9999 to be a valid iteration index
                if not (0 <= pos < 10000):
                    raise ValueError(
                        f"Derived position {pos} out of range for dll {j} from id {k}"
                    )
                unique_assignments.append((j, pos, k))

        # Consolidate unique assignments per dll to ensure consistency
        by_dll: Dict[int, List[Tuple[int, int]]] = defaultdict(list)
        for j, pos, k in unique_assignments:
            by_dll[j].append((pos, k))

        for j, lst in by_dll.items():
            # If multiple ids imply positions for the same dll, they must agree
            positions = {pos for (pos, _) in lst}
            if len(positions) != 1:
                details = ", ".join(f"pos={p} via id={k}" for (p, k) in lst)
                raise ValueError(f"Inconsistent positions for dll {j}: {details}")
            pos = positions.pop()
            # Assign position to dll j
            pos_by_dll[j] = pos
            unknown.discard(j)
            progress = True

            # This dll introduces some subset of modules (those not yet covered);
            # for each such k, its expected position must match pos and then it's covered exactly once.
            for k in s_by_dll[j]:
                if covered[k]:
                    continue
                if residual[k] != pos:
                    raise ValueError(
                        f"Conflict: assigning dll {j} at pos {pos} but id {k} expects {residual[k]}"
                    )
                residual[k] = 0
                covered[k] = True
                # Once covered, k no longer participates in contributor checks
                contributors[k].clear()

        # Optional: prune any ids that are fully satisfied (residual==0 and no unknown contributors)
        # Not strictly needed, but keeps struct smaller.
        # Also, detect contradictions early.
        for k in range(10000):
            if covered[k] or residual[k] == 0:
                continue
            active_js = [j for j in contributors[k] if j in unknown]
            if not active_js:
                # No remaining contributors but residual nonzero -> impossible
                raise ValueError(
                    f"Stuck: id {k} residual {residual[k]} has no remaining contributors"
                )

    if unknown:
        # Could not finish with pure elimination
        return None, pos_by_dll

    # Build order array from pos_by_dll
    order = [None] * 10000  # index i -> dll j
    for j, pos in pos_by_dll.items():
        if order[pos] is not None:
            raise ValueError(
                f"Duplicate position {pos} assigned to dlls {order[pos]} and {j}"
            )
        order[pos] = j
    if any(x is None for x in order):
        # Some positions unfilled (should not happen if we assigned all dlls)
        return None, pos_by_dll

    return order, pos_by_dll


def main():
    ap = argparse.ArgumentParser(
        description="Solve record order from Goal and enqueue sets S_j"
    )
    ap.add_argument(
        "--goal", required=True, help="Path to Goal (40000-byte .bin or JSON list)"
    )
    ap.add_argument(
        "--sets", required=True, help="Path to S_j JSON (dict dll_id -> list of ids)"
    )
    ap.add_argument(
        "--out-order",
        default="order.txt",
        help="Output path for order (one dll_id per line)",
    )
    ap.add_argument(
        "--verify",
        action="store_true",
        help="Simulate and verify that computed order reproduces Goal",
    )
    args = ap.parse_args()

    goal = load_goal(args.goal)
    s_by_dll = load_S(args.sets)

    # Basic sanity
    dll_ids = sorted(s_by_dll.keys())
    if len(dll_ids) != 10000 or dll_ids[0] != 0 or dll_ids[-1] != 9999:
        print(
            f"Warning: sets file defines {len(dll_ids)} dll ids; expected 10000 (0..9999)"
        )

    order, partial = solve_order(goal, s_by_dll)
    if order is None:
        print("Could not fully solve with elimination. Assigned so far:")
        print(f"  assigned={len(partial)}; remaining={10000 - len(partial)}")
        unresolved = sorted(set(range(10000)) - set(partial.keys()))
        print(f"  unresolved dlls (first 50): {unresolved[:50]}")
        return

    # Write order
    with open(args.out_order, "w", encoding="utf-8") as f:
        for j in order:
            f.write(f"{j}\n")

    print(f"Wrote order to {args.out_order}")

    if args.verify:
        sim = simulate(order, s_by_dll)
        ok = all((a & 0xFFFFFFFF) == (b & 0xFFFFFFFF) for a, b in zip(sim, goal))
        if ok:
            print("Verification passed: simulated counters match Goal.")
        else:
            mism = [(i, sim[i], goal[i]) for i in range(10000) if sim[i] != goal[i]]
            print(f"Verification FAILED. First mismatches (up to 10): {mism[:10]}")


if __name__ == "__main__":
    main()

```
{% endcode %}
{% endtab %}
{% endtabs %}
